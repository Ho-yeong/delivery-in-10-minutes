# 9장. 인터넷에서 돈을 보내는 법
## "암호화, HTTPS, 인증서, 결제 시스템"





---

> **이번 장에서 알게 될 것**
> - 인터넷에서 카드 번호가 어떻게 안전하게 전송되는지
> - 브라우저 주소창의 자물쇠 아이콘이 정확히 무엇을 의미하는지
> - 결제 버튼을 누르고 2초 동안 벌어지는 일
> - 전 세계 서버의 메모리를 들여다볼 수 있었던 치명적 버그

---

## 치킨 주문 여정: 결제 버튼을 누르다

> 치킨을 골랐습니다. 장바구니에 담았습니다.
> 결제 버튼을 누릅니다.
> 카드 번호 16자리가 인터넷을 타고 전송됩니다.
> 이 번호를 누군가 중간에서 훔쳐보면 어떻게 하죠?

---

## 엽서와 봉인된 편지



6장에서 카페 WiFi가 위험하다고 했습니다. 같은 네트워크에 있으면 오가는 데이터를 엿볼 수 있다고요. 그렇다면 카드 번호를 인터넷으로 보내는 것은 미친 짓일까요?

여기서 **암호화(Encryption)** 가 등장합니다.

암호화되지 않은 데이터를 보내는 것은 **엽서**를 보내는 것과 같습니다. 배달하는 사람 누구나 내용을 읽을 수 있습니다. 반면 암호화된 데이터를 보내는 것은 **봉인된 편지**를 보내는 것과 같습니다. 봉투를 뜯지 않는 한 내용을 알 수 없습니다.

[그림 9-1] HTTP와 HTTPS의 비교
```
  HTTP (암호화 없음) = 엽서
  ┌─────────────────────────┐
  │ 카드번호: 1234-5678-9012 │ ← 누구나 읽을 수 있음
  │ 유효기간: 12/27          │
  │ CVV: 123                │
  └─────────────────────────┘

  HTTPS (암호화) = 봉인된 편지
  ┌─────────────────────────┐
  │ aX7$k2!mP9qZ...        │ ← 암호화됨, 해독 불가
  │ Rj3#kL8nW2...          │
  └─────────────────────────┘
```

브라우저 주소창에서 `http://`로 시작하면 엽서, `https://`로 시작하면 봉인된 편지입니다. 's'는 Secure의 약자입니다.

---

## 대칭 암호: 같은 열쇠로 잠그고 열기

암호화의 가장 기본적인 방식은 **대칭 암호(Symmetric Encryption)** 입니다. 잠글 때와 열 때 **같은 열쇠**를 사용합니다.

[그림 9-2] 대칭 암호의 원리
```
  대칭 암호:

  보내는 사람                        받는 사람
  ┌────────┐    암호문    ┌────────┐
  │ 열쇠 A  │ ──────────→ │ 열쇠 A  │
  │        │  "aX7$k2!"  │        │
  │ 잠금   │             │ 해제   │
  └────────┘             └────────┘

  같은 열쇠 A로 잠그고, 같은 열쇠 A로 엽니다.
```

빠르고 효율적입니다. 하지만 치명적인 문제가 하나 있습니다.

**열쇠를 어떻게 전달하지?**

처음 만나는 사이인 내 폰과 배달의민족 서버가 같은 열쇠를 가져야 합니다. 그 열쇠를 인터넷으로 보내면? 열쇠 자체가 도청당합니다. 열쇠를 안전하게 보내려면 암호화가 필요한데, 암호화를 하려면 열쇠가 필요하고... 닭이 먼저냐 달걀이 먼저냐 같은 문제입니다.

---

## 비대칭 암호: 누구나 잠그지만, 열 수 있는 건 나뿐

이 문제를 해결하는 것이 **비대칭 암호(Asymmetric Encryption)** 입니다. 열쇠가 한 쌍으로 존재합니다. **공개 키(Public Key)** 와 **개인 키(Private Key)**.

아파트 무인택배함을 떠올려 보겠습니다.

[그림 9-3] 비대칭 암호와 무인택배함
```
  비대칭 암호 = 무인택배함:

  ┌────────────────────────────────────────┐
  │ 공개 키 = 택배함 투입                     │
  │  → 누구나 물건을 넣고 문을 닫을 수 있다     │
  │  → 택배함 위치는 공개해도 안전             │
  │                                        │
  │ 개인 키 = 택배함 비밀번호                  │
  │  → 오직 주인만 문을 열고 꺼낼 수 있다       │
  │  → 절대 공개하면 안 됨                    │
  └────────────────────────────────────────┘

  아무나:  공개 키로 잠근다 (물건을 넣고 닫는다)
  주인만:  개인 키로 연다  (물건을 꺼낸다)
```

공개 키로 잠근 것은 **개인 키로만** 열 수 있고, 개인 키로 잠근 것은 **공개 키로만** 열 수 있습니다. 공개 키는 전 세계에 뿌려도 괜찮습니다. 어차피 열 수 있는 것은 개인 키를 가진 사람뿐이니까요.

이것으로 "열쇠를 어떻게 전달하지?" 문제가 해결됩니다.

[그림 9-4] HTTPS 통신 과정
```
  실제 HTTPS 통신 과정:

  내 폰                              배민 서버
    │                                    │
    │   "너의 공개 키를 줘"                │
    │───────────────────────────────────→│
    │                                    │
    │   "여기 내 공개 키야"                │
    │←───────────────────────────────────│
    │                                    │
    │   공개 키로 대칭 키를 암호화해서 보냄   │
    │───────────────────────────────────→│
    │                                    │
    │   서버가 개인 키로 풀어서 대칭 키 획득  │
    │                                    │
    │   이제 둘 다 같은 대칭 키 보유!        │
    │←═══════ 대칭 키로 고속 암호화 ════════→│
```

처음에 비대칭 암호로 **대칭 키를 안전하게 교환**하고, 이후 실제 데이터는 빠른 **대칭 암호**로 주고받습니다. 두 방식의 장점을 합친 것입니다. 이 과정을 **TLS[^1] Handshake**라고 합니다.

---

## 인증서: 이 서버가 진짜 배달의민족인지 확인하기

그런데 한 가지 문제가 더 있습니다. 내 폰이 통신하는 상대가 정말 배달의민족 서버인지 어떻게 알까요? 해커가 가짜 배달의민족 서버를 만들고, 자기 공개 키를 보내면? 나는 해커의 공개 키로 카드 번호를 암호화해서 보내게 됩니다. 해커는 자기 개인 키로 풀어서 카드 번호를 가져갑니다.

이 문제를 해결하는 것이 **인증서(Certificate)** 입니다.

인증서는 **디지털 신분증**입니다. "이 공개 키는 정말로 배달의민족의 것이 맞습니다"라고 **인증 기관(CA)[^2]** 이 보증하는 것입니다.

[그림 9-5] 인증서 발급 과정
```
  인증서 발급 과정:

  배달의민족        인증 기관 (CA)          브라우저
      │                 │                   │
      │ "인증서 발급해줘" │                   │
      │ + 공개 키 제출   │                   │
      │─────────────→│                   │
      │                 │                   │
      │ "확인했어, 여기"  │                   │
      │ + 서명된 인증서   │                   │
      │←─────────────│                   │
      │                 │                   │
      │           접속 시 인증서 제시           │
      │──────────────────────────────────→│
      │                 │                   │
      │                 │   CA의 서명 검증     │
      │                 │   "진짜 배민이네!"   │
      │                 │   → 🔒 자물쇠 표시   │
```

브라우저 주소창의 **자물쇠 아이콘**이 바로 이것입니다. "이 사이트의 인증서를 인증 기관이 보증했으며, 통신이 암호화되어 있다"는 뜻입니다.

인증서가 없거나 만료되면 브라우저가 **"이 사이트는 안전하지 않습니다"** 경고를 띄웁니다. 이 경고가 뜨는 사이트에 카드 번호를 입력하면 안 되는 이유입니다.

2015년에 출범한 **Let's Encrypt**는 무료로 인증서를 발급해 줍니다. 이전에는 인증서 발급에 비용이 들었기 때문에 소규모 사이트는 HTTPS를 적용하지 못하는 경우가 많았습니다. Let's Encrypt 덕분에 현재 웹 트래픽의 **90% 이상**이 HTTPS로 암호화되어 있습니다.

---

## 결제 버튼을 누르면 2초 동안 벌어지는 일

암호화가 보장된 상태에서, 결제 버튼을 누르면 실제로 무슨 일이 일어나는지 따라가 보겠습니다. 치킨 18,000원을 카드로 결제합니다.

[그림 9-6] 온라인 결제 흐름
```
  결제 흐름 (약 2초):

  📱 내 폰
   │
   │ ① 카드 정보 + 주문 정보 (HTTPS 암호화)
   ▼
  PG사[^3] (결제 대행)
   │
   │ ② 결제 승인 요청
   ▼
  카드사 (삼성카드, 현대카드 등)
   │
   │ ③ 한도 확인, 승인
   ▼
  은행 (카드 연결 계좌)
   │
   │ ④ 잔액 확인, 출금 예약
   ▼
  카드사
   │
   │ ⑤ 승인 완료
   ▼
  PG사
   │
   │ ⑥ 결제 성공 알림
   ▼
  📱 내 폰: "결제가 완료되었습니다!"

  → 이 전체 과정이 약 2초
```

여기서 중요한 점은, **배달의민족 서버는 내 카드 번호를 저장하지 않습니다.** 카드 정보는 PG사가 처리하고, 배달앱은 "결제 성공/실패" 결과만 받습니다.

### 토큰화: 카드번호 대신 일회용 토큰

더 안전한 방법이 있습니다. **토큰화(Tokenization)** 입니다.

카드번호 `1234-5678-9012-3456` 대신, 아무 의미 없는 일회용 번호 `tk_8a7f2c...`를 생성해서 전송합니다. 이 토큰은 한 번 사용하면 폐기됩니다. 해커가 토큰을 가로채도 재사용이 불가능합니다.

삼성페이, 애플페이 같은 간편결제가 이 방식을 사용합니다. 실제 카드번호는 기기의 보안 영역에만 저장되고, 결제할 때는 매번 새로운 토큰을 생성해서 보냅니다.

---

## 사건 1: 2013 Target 해킹 — 4천만 장의 카드가 유출되다

2013년 미국 대형 마트 **Target**에서 역대 최대 규모의 카드 정보 유출 사건이 발생합니다. 약 **4천만 장**의 신용카드/체크카드 정보가 도난당했습니다.[^4]

해커들의 침입 경로는 의외였습니다. Target의 **냉난방 업체(HVAC)**를 먼저 해킹한 것입니다.

[그림 9-7] Target 해킹 경로
```
  Target 해킹 경로:

  해커
   │
   │ ① 냉난방 업체(HVAC)의 이메일로 피싱 공격
   ▼
  냉난방 업체 시스템 침입
   │
   │ ② HVAC이 Target 네트워크에 원격 접속 권한 보유
   ▼
  Target 내부 네트워크 침입
   │
   │ ③ POS 단말기[^5]에 악성코드 설치
   ▼
  카드 긁는 순간 정보 수집
   │
   │ ④ 수집된 데이터를 외부 서버로 전송
   ▼
  4천만 장의 카드 정보 유출
```

이 사건의 핵심 교훈은 **공급망 공격(Supply Chain Attack)** 입니다. 목표를 직접 공격하지 않고, 목표와 연결된 약한 고리(협력업체)를 먼저 공격합니다. 냉난방 업체의 보안이 뚫리면서, 미국 최대 유통기업의 결제 시스템이 뚫렸습니다.

---

## 사건 2: Heartbleed — 인터넷의 심장에 구멍이 뚫리다

2014년 4월, **Heartbleed**라는 이름의 취약점이 공개됩니다.[^6]

이 버그는 HTTPS 암호화를 담당하는 핵심 소프트웨어 **OpenSSL[^7]** 에서 발견되었습니다. 전 세계 웹 서버의 약 **3분의 2**가 이 소프트웨어를 사용하고 있었습니다.

버그의 내용은 이렇습니다. TLS에는 연결이 살아있는지 확인하는 **Heartbeat(심장 박동)** 기능이 있습니다. "나 살아있어, 5글자 보낼게: HELLO" → "응, 받았어: HELLO". 그런데 악의적으로 "나 살아있어, 500글자 보낼게: HI"라고 보내면?

[그림 9-8] Heartbleed 취약점의 원리
```
  Heartbleed 원리:

  정상적인 요청:
  "5글자 보낼게: HELLO"
  → 서버 응답: "HELLO"  (5글자 그대로 되돌려 보냄)

  악의적 요청:
  "500글자 보낼게: HI"
  → 서버: HI 뒤에 498글자를 메모리에서 읽어서 보냄!
  → "HI" + [서버 메모리에 있던 498글자]
  → 비밀번호, 세션 키, 개인 키 등이 유출될 수 있음
```

서버가 "500글자를 보내라고 했으니" 실제로 2글자만 받았어도 메모리에서 나머지 498글자를 읽어서 보내버린 것입니다. 서버 메모리에는 다른 사용자의 비밀번호, 암호화 키, 개인 정보가 들어 있습니다. 이것이 외부로 유출된 겁니다.

이 버그가 Heartbleed(심장 출혈)라는 이름을 얻은 이유입니다 — Heartbeat 기능에서 피가 새듯 정보가 새어나갔습니다.

가장 충격적인 것은 이 버그가 **2년 넘게** 발견되지 않았다는 사실입니다. 2011년 말에 코드에 들어간 버그가 2014년에야 발견되었습니다. 그 사이에 얼마나 많은 정보가 유출되었는지는 알 수 없습니다 — Heartbleed는 로그를 남기지 않기 때문입니다.

---

## 알쓸신잡

- **카드 뒷면 CVV의 역할**: 카드 뒷면의 3자리 숫자를 **CVV(Card Verification Value)** 라고 합니다. 온라인 결제에서 "실물 카드를 가지고 있다"는 것을 증명하는 역할입니다. 카드 번호와 유효기간은 카드 앞면에 있어서 사진만 찍어도 유출되지만, CVV는 뒷면에 있어서 별도로 확인해야 합니다. 물론 완벽한 보안은 아니지만, 한 겹의 방어선을 더하는 것입니다.

- **비트코인과 블록체인**: 기존 결제 시스템은 "은행"이라는 중앙 기관이 거래를 검증합니다. 비트코인은 은행 없이 거래를 검증하는 시스템입니다. 모든 거래 내역을 **블록체인(Blockchain)** 이라는 공개 장부에 기록하고, 네트워크 참여자 전원이 이를 검증합니다. 누군가 장부를 조작하려면 전체 네트워크의 과반수를 동시에 속여야 하므로 사실상 불가능합니다. 은행이 하던 "신뢰"의 역할을 수학과 네트워크로 대체한 것입니다.

- **"이 사이트는 안전하지 않습니다"의 진짜 의미**: 이 경고는 "이 사이트가 해킹당했다"는 뜻이 **아닙니다**. "이 사이트가 HTTPS를 사용하지 않거나, 인증서에 문제가 있다"는 뜻입니다. 통신이 암호화되지 않을 수 있으므로 개인정보 입력을 주의하라는 것입니다. 단, 피싱 사이트가 유효한 인증서를 가지고 있는 경우도 있으므로, 자물쇠가 있다고 해서 100% 안전한 것은 아닙니다 — "통신은 안전하지만, 상대방이 사기꾼일 수 있다"는 뜻입니다.

결제가 완료되었습니다. 그런데 잠깐 — 이 결제를 하려면 먼저 배달앱에 **로그인**을 해야 했습니다. 비밀번호를 입력하고 로그인 버튼을 누르면, 그 비밀번호는 어디로 가는 걸까요? 서버에 저장되나요? 그렇다면 해킹당하면 내 비밀번호가 그대로 노출되는 건 아닐까요?

---

[^1]: TLS(Transport Layer Security): 전송 계층 보안. HTTPS에서 실제 암호화를 담당하는 프로토콜. 과거에는 SSL(Secure Sockets Layer)이라 불렀으나, 현재는 TLS로 대체되었다. SSL이라는 이름이 더 익숙하지만, 실제로 사용되는 것은 TLS다.
[^2]: CA(Certificate Authority): 인증 기관. 디지털 인증서를 발급하고 검증하는 신뢰할 수 있는 제3자 기관. Let's Encrypt, DigiCert, GlobalSign 등이 있다.
[^3]: PG사(Payment Gateway): 결제 대행사. 온라인 쇼핑몰이 직접 카드사와 계약하지 않아도 결제를 처리할 수 있도록 중간에서 대행하는 회사. 한국에서는 NHN KCP, 토스페이먼츠, 나이스페이 등이 대표적.
[^4]: 카드 정보 4천만 건 + 개인정보 7천만 건, 총 1억 1천만 건 영향. — [Krebs on Security](https://krebsonsecurity.com/2014/05/the-target-breach-by-the-numbers/)
[^5]: POS 단말기(Point of Sale Terminal): 매장에서 카드를 긁거나 태그하는 결제 장치.
[^6]: CVE-2014-0160. 2011년 말 코드에 도입, 2014년 4월 7일 공개. — [heartbleed.com](https://heartbleed.com/)
[^7]: OpenSSL: 암호화 통신을 구현하는 오픈소스 소프트웨어. 전 세계 웹 서버, 이메일 서버, VPN 등에 광범위하게 사용된다.
